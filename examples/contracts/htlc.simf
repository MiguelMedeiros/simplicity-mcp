// htlc.simf - Hash Time Lock Contract
// Advanced example showing conditional payments with hash preimage or timeout
// NOTE: This version uses advanced features (custom functions, match, Either type)
// that may not be fully supported by the current simc compiler

// Witness data - determines which spending path to use
witness! {
    // Either spend with preimage (Left) or timeout (Right)
    // Left: (preimage, recipient_signature)
    // Right: sender_signature
    COMPLETE_OR_CANCEL: Either<(u256, Signature), Signature>
        = Left((0x9bf49a6a0755f953811fce125f2683d50429c3bb49e074147e0089a52eae155f,
                0x307f7dacb1b529ed8a758a35ac9cc846d72b5ffefadf5ac4d055d7c8029ac6b1b5a29ad7e738b5eb8a372980c23872dfb8fe7f30a4970f754ca6dfeb8e5b265a));
}

// Parameters hardcoded in contract
const ALICE_PUBLIC_KEY: u256 = 0x9bef8d556d80e43ae7e0becb3a7e6838b95defe45896ed6075bb9035d06c9964;
const BOB_PUBLIC_KEY: u256 = 0xe37d58a1aae4ba059fd2503712d998470d3a2522f7e2335f544ef384d2199e02;
const EXPECTED_HASH: u256 = 0x3034f1d855651180a6ae0ab3fb46c2b87501297e491e665a097f2f7d4ef5c835;

fn sha2(string: u256) -> u256 {
    let hasher: Ctx8 = jet::sha_256_ctx_8_init();
    let hasher: Ctx8 = jet::sha_256_ctx_8_add_32(hasher, string);
    jet::sha_256_ctx_8_finalize(hasher)
}

fn checksig(pk: Pubkey, sig: Signature) {
    let msg: u256 = jet::sig_all_hash();
    jet::bip_0340_verify((pk, msg), sig);
}

fn complete_spend(preimage: u256, recipient_sig: Signature) {
    let hash: u256 = sha2(preimage);
    assert!(jet::eq_256(hash, EXPECTED_HASH));
    let recipient_pk: Pubkey = ALICE_PUBLIC_KEY;
    checksig(recipient_pk, recipient_sig);
}

fn cancel_spend(sender_sig: Signature) {
    let timeout: Height = 1000;
    jet::check_lock_height(timeout);
    let sender_pk: Pubkey = BOB_PUBLIC_KEY;
    checksig(sender_pk, sender_sig)
}

fn main() {
    match COMPLETE_OR_CANCEL {
        Left(preimage_and_sig: (u256, Signature)) => {
            let (preimage, recipient_sig): (u256, Signature) = preimage_and_sig;
            complete_spend(preimage, recipient_sig);
        },
        Right(sender_sig: Signature) => cancel_spend(sender_sig),
    }
}